// backend/index.js
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const { body, validationResult } = require('express-validator');
const { GoogleGenerativeAI } = require('@google/generative-ai');
const fs = require('fs');
const readline = require('readline');
const { elkMCPClient } = require('./services/elkMCPClient');
const { ELK_CONFIG, OWASP_REFERENCES, identifyOWASPType, ATTACK_PATH_CATEGORIES, categorizeAttackPathByConfig } = require('./config/elkConfig');
const { CLOUDFLARE_FIELD_MAPPING, generateAIFieldReference } = require('../cloudflare-field-mapping');
const TrendAnalysisService = require('./services/trendAnalysisService');
const { SECURITY_CONFIG, validateSecurityConfig, isValidApiKey } = require('./config/security');
const { aiProviderManager } = require('./services/aiProviderManager');

const app = express();

// 驗證安全配置
const securityConfig = validateSecurityConfig();

// 安全中間件
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"],
    },
  },
  crossOriginEmbedderPolicy: false
}));

// CORS配置
app.use(cors({
  origin: securityConfig.app.corsOrigins,
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization']
}));

// 速率限制
const limiter = rateLimit({
  windowMs: securityConfig.rateLimit.windowMs,
  max: securityConfig.rateLimit.max,
  message: {
    error: '請求過於頻繁，請稍後再試',
    retryAfter: Math.ceil(securityConfig.rateLimit.windowMs / 1000)
  },
  standardHeaders: true,
  legacyHeaders: false
});

app.use('/api/', limiter);

// JSON解析中間件
app.use(express.json({ limit: securityConfig.validation.maxRequestSize }));

// 請求日誌中間件
app.use((req, res, next) => {
  console.log(`${new Date().toISOString()} - ${req.method} ${req.path}`);
  next();
});

// 初始化趨勢分析服務
const trendAnalysisService = new TrendAnalysisService();

// --- 常數設定 ---
const LOG_FILE_PATH = '../CF-http_log.txt';
const TIME_WINDOW_SECONDS = 10;
// 移除攻擊閾值限制，因為 Cloudflare 已經做了初步判斷
// const ATTACK_THRESHOLD = 20;

// --- 工具函數 ---
// 生成分析 ID
function generateAnalysisId() {
  return Math.random().toString(36).substr(2, 9);
}

// 計算攻擊嚴重程度評分
function calculateAttackSeverity(attack) {
  let score = 0;
  
  // 基礎分數：攻擊來源數量
  score += attack.sourceList.size * 10;
  
  // 流量分數：總位元組數
  score += (attack.totalBytes || 0) / 1000;
  
  // Host header 偽造懲罰（更高風險）
  if (attack.claimedDomain) {
    score += 50;  // 偽造 Host header 是高風險行為
  }
  
  // 敏感路徑攻擊加分
  const targetURL = attack.targetURL || '';
  if (targetURL.includes('.env') || targetURL.includes('config') || 
      targetURL.includes('admin') || targetURL.includes('.git')) {
    score += 30;
  }
  
  return Math.round(score);
}

// 建立攻擊關聯圖
function buildAttackRelationshipGraph(allAttacks) {
  if (!allAttacks || allAttacks.length === 0) {
    return null;
  }

  // 建立IP集群 - 找出多目標攻擊者
  const ipGroups = new Map();
  const domainGroups = new Map();
  const pathTypeGroups = new Map();

  allAttacks.forEach(attack => {
    // 從攻擊ID解析出IP（格式: IP@domain）
    const [sourceIP] = attack.id.split('@');
    
    // IP集群分析
    if (!ipGroups.has(sourceIP)) {
      ipGroups.set(sourceIP, {
        ip: sourceIP,
        targets: [],
        totalSeverity: 0,
        techniques: new Set(),
        isMultiTarget: false
      });
    }
    
    const ipGroup = ipGroups.get(sourceIP);
    ipGroup.targets.push({
      domain: attack.domain,
      claimedDomain: attack.claimedDomain,
      targetURL: attack.targetURL,
      severity: attack.severity
    });
    ipGroup.totalSeverity += attack.severity;
    ipGroup.isMultiTarget = ipGroup.targets.length > 1;
    
    // 分析攻擊技術
    if (attack.claimedDomain) ipGroup.techniques.add('Host偽造');
    if (attack.targetURL?.includes('.env')) ipGroup.techniques.add('環境檔案探測');
    if (attack.targetURL?.includes('config')) ipGroup.techniques.add('配置檔案探測');
    if (attack.targetURL?.includes('admin')) ipGroup.techniques.add('管理介面探測');
    if (attack.targetURL?.includes('.git')) ipGroup.techniques.add('版本控制探測');
    
    // 域名基礎設施分析
    const baseDomain = attack.domain.split('.').slice(-2).join('.');
    if (!domainGroups.has(baseDomain)) {
      domainGroups.set(baseDomain, {
        baseDomain: baseDomain,
        subdomains: new Set(),
        attackers: new Set()
      });
    }
    domainGroups.get(baseDomain).subdomains.add(attack.domain);
    domainGroups.get(baseDomain).attackers.add(sourceIP);
    
    // 攻擊路徑類型分析
    const pathType = categorizeAttackPath(attack.targetURL);
    if (!pathTypeGroups.has(pathType)) {
      pathTypeGroups.set(pathType, {
        type: pathType,
        count: 0,
        examples: []
      });
    }
    const pathGroup = pathTypeGroups.get(pathType);
    pathGroup.count++;
    if (pathGroup.examples.length < 3) {
      pathGroup.examples.push(attack.targetURL);
    }
  });

  // 🎯 優化：只選擇 Top 5 攻擊IP來避免關聯圖過於複雜
  const sortedIpGroups = Array.from(ipGroups.values())
    .sort((a, b) => b.totalSeverity - a.totalSeverity)
    .slice(0, 5); // 只取前5個最嚴重的攻擊IP
  
  console.log(`🔍 關聯圖優化：從 ${ipGroups.size} 個攻擊IP中選擇Top 5進行顯示`);
  sortedIpGroups.forEach((group, index) => {
    console.log(`  ${index + 1}. ${group.ip} - 嚴重程度: ${group.totalSeverity}, 目標數: ${group.targets.length}`);
  });
  
  // 重新建立優化後的 ipGroups 和相關的 domainGroups
  const optimizedIpGroups = new Map();
  const optimizedDomainGroups = new Map();
  
  sortedIpGroups.forEach(group => {
    optimizedIpGroups.set(group.ip, group);
    
    // 重新計算相關的域名資訊
    group.targets.forEach(target => {
      const baseDomain = target.domain.split('.').slice(-2).join('.');
      if (!optimizedDomainGroups.has(baseDomain)) {
        optimizedDomainGroups.set(baseDomain, {
          baseDomain: baseDomain,
          subdomains: new Set(),
          attackers: new Set()
        });
      }
      optimizedDomainGroups.get(baseDomain).subdomains.add(target.domain);
      optimizedDomainGroups.get(baseDomain).attackers.add(group.ip);
    });
  });

  // 計算關聯強度（使用優化後的資料）
  const correlationStrength = calculateCorrelationStrength(optimizedIpGroups, optimizedDomainGroups);

  return {
    // IP攻擊者分析（僅Top 5）
    ipClusters: Array.from(optimizedIpGroups.values()).map(group => ({
      ...group,
      techniques: Array.from(group.techniques),
      riskLevel: group.totalSeverity > 100 ? 'High' : group.totalSeverity > 50 ? 'Medium' : 'Low'
    })),
    
    // 目標基礎設施分析（基於Top 5 IP）
    infrastructureMap: Array.from(optimizedDomainGroups.values()).map(group => ({
      ...group,
      subdomains: Array.from(group.subdomains),
      attackers: Array.from(group.attackers),
      isTargetedInfrastructure: group.attackers.size > 1 || group.subdomains.size > 2
    })),
    
    // 攻擊模式分析（優化：只顯示 Top 5 攻擊路徑）
    attackPatternAnalysis: Array.from(pathTypeGroups.values())
      .sort((a, b) => b.count - a.count)
      .slice(0, 5),
    
    // 關聯強度評估
    correlationMetrics: {
      strength: correlationStrength,
      multiTargetAttackers: Array.from(optimizedIpGroups.values()).filter(g => g.isMultiTarget).length,
      coordinatedAttack: correlationStrength > 0.7,
      infrastructureScope: Array.from(optimizedDomainGroups.values())[0]?.subdomains?.size || 0,
      // 新增：顯示優化資訊
      totalIPs: ipGroups.size,
      displayedIPs: optimizedIpGroups.size,
      optimized: ipGroups.size > 5
    }
  };
}

// 分類攻擊路徑類型（配置驅動）
function categorizeAttackPath(url) {
  // 使用配置驅動的分類函數
  const result = categorizeAttackPathByConfig(url);
  
  // 為了保持向後兼容性，只返回分類名稱
  return result.category || result;
}

// 獲取詳細的攻擊路徑分類資訊（包含描述和匹配模式）
function categorizeAttackPathDetailed(url) {
  return categorizeAttackPathByConfig(url);
}

// 計算攻擊關聯強度
function calculateCorrelationStrength(ipGroups, domainGroups) {
  let strength = 0;
  
  // 多目標攻擊者加權
  const multiTargetCount = Array.from(ipGroups.values()).filter(g => g.isMultiTarget).length;
  strength += multiTargetCount * 0.3;
  
  // 基礎設施集中度加權
  const infraConcentration = Array.from(domainGroups.values())[0]?.subdomains?.size || 0;
  strength += Math.min(infraConcentration * 0.2, 0.4);
  
  // 攻擊技術多樣性加權
  const totalTechniques = new Set();
  ipGroups.forEach(group => {
    if (group.techniques) {
      group.techniques.forEach(tech => totalTechniques.add(tech));
    }
  });
  strength += Math.min(totalTechniques.size * 0.1, 0.3);
  
  return Math.min(strength, 1.0);
}

// 載入配置檔案（如果存在）
let config = {};
try {
  config = require('./config.js');
} catch (error) {
  // 配置檔案不存在，使用 UI 設定
}

// 可用的 Gemini 模型 (2.5 系列)
const AVAILABLE_MODELS = [
  { id: 'gemini-2.5-pro', name: 'Gemini 2.5 Pro' },
  { id: 'gemini-2.5-flash', name: 'Gemini 2.5 Flash' },
  { id: 'gemini-2.5-flash-lite', name: 'Gemini 2.5 Flash Lite' }
];

// 取得可用的模型列表
app.get('/api/models', (_req, res) => {
  res.json(AVAILABLE_MODELS);
});

// /api/analyze-log 端點已移除，統一使用 ELK 即時模式

// 原始 AI 分析端點 (現在主要由後端內部呼叫)
app.post('/api/analyze', async (req, res) => {
  try {
    const analysis = await getAIAssessment(req.body);
    res.json(analysis);
  } catch (error) {
    console.error('AI 分析錯誤:', error);
    res.status(500).json({ 
      error: 'AI 分析失敗',
      details: error.message 
    });
  }
});

// 新增：取得 Ollama 模型列表
app.post('/api/ollama/models', async (req, res) => {
  try {
    const { apiUrl } = req.body;
    
    if (!apiUrl) {
      return res.status(400).json({ error: '缺少 Ollama API URL' });
    }

    console.log(`🔍 獲取 Ollama 模型列表: ${apiUrl}`);
    
    const result = await aiProviderManager.getProviderModels('ollama', { apiUrl });
    
    console.log(`✅ 成功獲取 ${result.models.length} 個 Ollama 模型`);
    
    res.json({
      success: true,
      models: result.models,
      count: result.models.length
    });
  } catch (error) {
    console.error('獲取 Ollama 模型列表失敗:', error);
    res.status(500).json({ 
      error: '獲取 Ollama 模型列表失敗',
      details: error.message 
    });
  }
});

// 新增：提供商特定的 AI 測試端點
app.post('/api/test-ai/:provider', async (req, res) => {
  try {
    const { provider } = req.params;
    const requestBody = req.body;

    console.log(`🧪 收到 ${provider} AI 測試請求`);
    console.log(`📋 請求參數:`, Object.keys(requestBody));

    let config;
    switch (provider) {
      case 'gemini':
        const { apiKey, model } = requestBody;
        if (!apiKey || !model) {
          console.log('❌ Gemini 參數不完整');
          return res.status(400).json({ error: '缺少 Gemini API Key 或模型' });
        }
        config = { apiKey, model };
        console.log(`🔑 Gemini 配置: 模型=${model}, API Key 長度=${apiKey.length}`);
        break;

      case 'ollama':
        const { apiUrl, model: ollamaModel } = requestBody;
        if (!apiUrl || !ollamaModel) {
          console.log('❌ Ollama 參數不完整');
          return res.status(400).json({ error: '缺少 Ollama API URL 或模型' });
        }
        config = { apiUrl, model: ollamaModel };
        console.log(`🔗 Ollama 配置: URL=${apiUrl}, 模型=${ollamaModel}`);
        break;

      default:
        console.log(`❌ 不支援的提供商: ${provider}`);
        return res.status(400).json({ error: `不支援的 AI 提供商: ${provider}` });
    }

    // 驗證配置 (純 AI 提供商驗證，不涉及外部服務)
    console.log(`🔍 驗證 ${provider} 配置...`);
    aiProviderManager.validateProviderConfig(provider, config);
    console.log(`✅ ${provider} 配置驗證通過`);

    // 執行純 AI 連接測試，完全獨立於其他服務
    console.log(`🚀 開始 ${provider} 純 AI 連接測試...`);
    const startTime = Date.now();
    const result = await aiProviderManager.testProvider(provider, config);
    const totalTime = Date.now() - startTime;

    console.log(`✅ ${provider} 連接測試成功，總耗時 ${totalTime}ms`);

    res.json({
      success: true,
      message: result.message,
      provider: provider,
      model: config.model,
      response: result.response || null,
      responseTime: result.responseTime || totalTime,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    const provider = req.params.provider;
    console.error(`❌ ${provider} 測試錯誤:`, error);
    
    // 詳細的錯誤分類和狀態碼
    let statusCode = 500;
    let errorMessage = `${provider} 測試失敗`;
    
    if (error.message.includes('API Key 無效')) {
      statusCode = 401;
      errorMessage = `${provider} API Key 無效`;
    } else if (error.message.includes('配額已超限')) {
      statusCode = 429;
      errorMessage = `${provider} API 配額已超限`;
    } else if (error.message.includes('模型不存在')) {
      statusCode = 404;
      errorMessage = `${provider} 模型不可用`;
    } else if (error.message.includes('連接失敗') || error.message.includes('ECONNREFUSED')) {
      statusCode = 503;
      errorMessage = `${provider} 服務連接失敗`;
    } else if (error.message.includes('URL 格式無效')) {
      statusCode = 400;
      errorMessage = `${provider} 配置格式錯誤`;
    }
    
    res.status(statusCode).json({ 
      error: errorMessage,
      details: error.message,
      provider: provider,
      timestamp: new Date().toISOString()
    });
  }
});

// 新增：列出支援的 AI 提供商
app.get('/api/ai-providers', (_req, res) => {
  try {
    const providers = aiProviderManager.listSupportedProviders();
    res.json({
      success: true,
      providers: providers
    });
  } catch (error) {
    console.error('獲取 AI 提供商列表失敗:', error);
    res.status(500).json({ 
      error: '獲取 AI 提供商列表失敗',
      details: error.message 
    });
  }
});

// 修改現有的 AI 測試端點以保持向後兼容
app.post('/api/test-ai', async (req, res) => {
  try {
    console.log('🧪 收到 AI 測試請求 (向後兼容端點)');
    
    const { apiKey, model } = req.body;
    const useApiKey = apiKey || config.GEMINI_API_KEY;
    const useModel = model || config.GEMINI_MODEL || 'gemini-1.5-flash';

    if (!useApiKey) {
      console.log('❌ 缺少 API Key');
      return res.status(400).json({ error: '缺少 API Key' });
    }

    console.log(`🔑 使用模型: ${useModel}`);

    // 使用新的提供商管理器進行純 AI 測試，完全獨立於其他服務
    const result = await aiProviderManager.testProvider('gemini', {
      apiKey: useApiKey,
      model: useModel
    });

    console.log('✅ AI 測試成功完成');
    
    res.json({
      success: true,
      message: '✅ AI 連接測試成功',
      model: useModel,
      response: result.response,
      responseTime: result.responseTime || 0
    });

  } catch (error) {
    console.error('❌ AI 測試錯誤:', error);
    
    // 提供詳細的錯誤反饋
    let statusCode = 500;
    let errorMessage = 'AI 測試失敗';
    
    if (error.message.includes('API Key 無效')) {
      statusCode = 401;
      errorMessage = 'API Key 無效';
    } else if (error.message.includes('配額已超限')) {
      statusCode = 429;
      errorMessage = 'API 配額已超限';
    } else if (error.message.includes('網路連接失敗')) {
      statusCode = 503;
      errorMessage = '網路連接失敗';
    }
    
    res.status(statusCode).json({ 
      error: errorMessage,
      details: error.message,
      timestamp: new Date().toISOString()
    });
  }
});

// --- 核心邏輯函式 (檔案模式相關函數已移除，統一使用 ELK 即時模式) ---

// processLogFile 函數已移除，統一使用 ELK 即時模式

  for await (const line of rl) {
    if (!line.trim()) continue;
    try {
      const logEntry = JSON.parse(line);
      updateGlobalStats(logEntry, globalStats);
      detectAttack(logEntry, null, detectedAttacks); // 不再需要 ipRequestCounts
    } catch (e) {
      // 忽略解析錯誤
    }
  }

  console.log(`✅ 日誌檔案掃描完畢。偵測到 ${Object.keys(detectedAttacks).length} 起攻擊。`);

  if (Object.keys(detectedAttacks).length > 0) {
    // 處理所有偵測到的攻擊，選擇最嚴重的一起進行詳細分析
    console.log(`🔍 發現 ${Object.keys(detectedAttacks).length} 起攻擊事件:`);
    
    let selectedAttackId = null;
    let selectedAttack = null;
    let maxScore = 0;
    
    // 分析所有攻擊並選擇最嚴重的
    for (const [attackId, attack] of Object.entries(detectedAttacks)) {
      const attackScore = calculateAttackSeverity(attack);
      console.log(`   攻擊 ${attackId}:`);
      console.log(`     域名: ${attack.attackDomain}`);
      console.log(`     來源數: ${attack.sourceList.size}`);
      console.log(`     嚴重程度: ${attackScore}`);
      
      if (attack.claimedDomain) {
        console.log(`     ⚠️  偽造 Host header: ${attack.claimedDomain}`);
      }
      
      if (attackScore > maxScore) {
        maxScore = attackScore;
        selectedAttackId = attackId;
        selectedAttack = attack;
      }
    }
    
    console.log(`\n🎯 選擇分析攻擊: ${selectedAttackId} (嚴重程度: ${maxScore})`);
    
    // 準備所有攻擊的摘要
    const allAttacks = Object.entries(detectedAttacks).map(([id, attack]) => ({
      id: id,
      domain: attack.attackDomain,
      claimedDomain: attack.claimedDomain,
      sourceCount: attack.sourceList.size,
      targetURL: attack.targetURL,
      severity: calculateAttackSeverity(attack)
    }));
    
    const attackData = {
      attackDomain: selectedAttack.attackDomain,
      claimedDomain: selectedAttack.claimedDomain,  // 包含可能偽造的域名
      targetIP: "N/A",
      targetURL: selectedAttack.targetURL,
      attackTrafficGbps: (selectedAttack.totalBytes * 8) / (TIME_WINDOW_SECONDS * 1e9),
      sourceList: Array.from(selectedAttack.sourceList.values()),
      allAttacks: allAttacks,
      attackGraph: buildAttackRelationshipGraph(allAttacks)
    };
    
    // 加入詳細的攻擊模式資訊
    const getTop5 = (map) => Array.from(map.entries()).sort(([, a], [, b]) => b - a).slice(0, 5).map(([key, value]) => ({ item: key, count: value }));
    const detailedAttackData = {
      ...attackData,
      // 基本統計
      totalRequests: globalStats.totalRequests,
      uniqueIPs: globalStats.uniqueIPs.size,
      timeRange: {
        start: globalStats.firstTimestamp ? globalStats.firstTimestamp.toISOString() : 'N/A',
        end: globalStats.lastTimestamp ? globalStats.lastTimestamp.toISOString() : 'N/A',
      },
      // 安全事件統計
      securityEvents: {
        blockedRequests: globalStats.securityEvents.blockedRequests,
        highRiskRequests: globalStats.securityEvents.highRiskRequests,
        topSecurityRules: getTop5(globalStats.securityEvents.securityRules),
      },
      // 攻擊模式分析
      attackPatterns: {
        sensitiveFiles: getTop5(globalStats.attackPatterns.sensitiveFiles),
        adminPanels: getTop5(globalStats.attackPatterns.adminPanels),
        configFiles: getTop5(globalStats.attackPatterns.configFiles),
        versionControl: getTop5(globalStats.attackPatterns.versionControl),
        sqlInjection: getTop5(globalStats.attackPatterns.sqlInjection),
        xssAttempts: getTop5(globalStats.attackPatterns.xssAttempts),
      },
      // 地理和IP分佈
      topCountries: getTop5(globalStats.countryCounts),
      topIPs: getTop5(globalStats.ipCounts),
      topURIs: getTop5(globalStats.uriCounts),
    };
    
    // 顯示關聯圖摘要
    console.log('\n🔗 攻擊關聯圖摘要:');
    if (detailedAttackData.attackGraph) {
      console.log(`關聯強度: ${(detailedAttackData.attackGraph.correlationMetrics.strength * 100).toFixed(1)}%`);
      console.log(`多目標攻擊者: ${detailedAttackData.attackGraph.correlationMetrics.multiTargetAttackers} 個`);
      console.log(`基礎設施規模: ${detailedAttackData.attackGraph.correlationMetrics.infrastructureScope} 個域名`);
      console.log('IP集群:');
      detailedAttackData.attackGraph.ipClusters.forEach((cluster, index) => {
        console.log(`  ${index + 1}. ${cluster.ip} [${cluster.riskLevel}] - 目標: ${cluster.targets.length}, 技術: ${cluster.techniques.join(', ')}`);
      });
    } else {
      console.log('無關聯圖資料');
    }
    
    const aiAnalysis = await getAIAssessment({ ...config, attackData: detailedAttackData });
    // 將攻擊資料包含在回傳結果中，並包含WAF分數資料
    return { 
      ...aiAnalysis, 
      attackData,
      wafScoreData: globalStats.wafScoreData || [],
      globalStats,
    };
  } else {
    const getTop5 = (map) => Array.from(map.entries()).sort(([, a], [, b]) => b - a).slice(0, 5).map(([key, value]) => ({ item: key, count: value }));
    
    // 判斷是否為純事件日誌（沒有流量資料）
    const avgBytesPerRequest = globalStats.totalRequests > 0 ? globalStats.totalBytes / globalStats.totalRequests : 0;
    const isEventOnlyLog = globalStats.totalBytes === 0 || avgBytesPerRequest < 100;
    
    if (isEventOnlyLog) {
      // 純事件日誌分析
      const eventData = {
        timeRange: {
          start: globalStats.firstTimestamp ? globalStats.firstTimestamp.toISOString() : 'N/A',
          end: globalStats.lastTimestamp ? globalStats.lastTimestamp.toISOString() : 'N/A',
        },
        totalEvents: globalStats.totalRequests,
        uniqueIPs: globalStats.uniqueIPs.size,
        topCountries: getTop5(globalStats.countryCounts),
        topIPs: getTop5(globalStats.ipCounts),
        topURIs: getTop5(globalStats.uriCounts),
        logType: 'event_only'
      };
      const aiAnalysis = await getAIAssessment({ ...config, eventData });
      return { 
        ...aiAnalysis, 
        wafScoreData: globalStats.wafScoreData || [],
        globalStats,
      };
    } else {
             // 整體摘要分析（包含流量和事件資料）
       const overallData = {
         timeRange: {
           start: globalStats.firstTimestamp ? globalStats.firstTimestamp.toISOString() : 'N/A',
           end: globalStats.lastTimestamp ? globalStats.lastTimestamp.toISOString() : 'N/A',
         },
         totalRequests: globalStats.totalRequests,
         uniqueIPs: globalStats.uniqueIPs.size,
         totalGB: (globalStats.totalBytes / (1024 ** 3)).toFixed(4),
         avgBytesPerRequest: globalStats.totalRequests > 0 ? (globalStats.totalBytes / globalStats.totalRequests).toFixed(2) : 0,
         topCountries: getTop5(globalStats.countryCounts),
         topIPs: getTop5(globalStats.ipCounts),
         topURIs: getTop5(globalStats.uriCounts),
         // 新增：詳細攻擊模式分析
         securityEvents: {
           blockedRequests: globalStats.securityEvents.blockedRequests,
           highRiskRequests: globalStats.securityEvents.highRiskRequests,
           topSecurityRules: getTop5(globalStats.securityEvents.securityRules),
         },
         attackPatterns: {
           sensitiveFiles: getTop5(globalStats.attackPatterns.sensitiveFiles),
           adminPanels: getTop5(globalStats.attackPatterns.adminPanels),
           configFiles: getTop5(globalStats.attackPatterns.configFiles),
           versionControl: getTop5(globalStats.attackPatterns.versionControl),
           sqlInjection: getTop5(globalStats.attackPatterns.sqlInjection),
           xssAttempts: getTop5(globalStats.attackPatterns.xssAttempts),
         },
         logType: 'comprehensive'
       };
      const aiAnalysis = await getAIAssessment({ ...config, overallData });
      return { 
        ...aiAnalysis, 
        wafScoreData: globalStats.wafScoreData || [],
        globalStats,
      };
    }
  }
}

function updateGlobalStats(logEntry, globalStats) {
  globalStats.totalRequests++;
  globalStats.totalBytes += logEntry.EdgeResponseBytes || 0;
  globalStats.uniqueIPs.add(logEntry.ClientIP);
  
  // 時間戳處理
  if (logEntry.EdgeStartTimestamp) {
    try {
      const currentTimestamp = new Date(logEntry.EdgeStartTimestamp);
      if (!isNaN(currentTimestamp.getTime())) {
        if (!globalStats.firstTimestamp || currentTimestamp < globalStats.firstTimestamp) globalStats.firstTimestamp = currentTimestamp;
        if (!globalStats.lastTimestamp || currentTimestamp > globalStats.lastTimestamp) globalStats.lastTimestamp = currentTimestamp;
      }
    } catch (e) {}
  }
  
  // 收集WAF分數資料
  if (!globalStats.wafScoreData) globalStats.wafScoreData = [];
  if (logEntry.ClientRequestURI && logEntry.WAFAttackScore !== undefined) {
    globalStats.wafScoreData.push({
      uri: logEntry.ClientRequestURI,
      wafScore: logEntry.WAFAttackScore || 0,
      clientIP: logEntry.ClientIP,
      timestamp: logEntry.EdgeStartTimestamp
    });
  }
  
  // 基本統計
  const { ClientCountry, ClientIP, ClientRequestURI, SecurityAction, WAFAttackScore, WAFSQLiAttackScore, WAFXSSAttackScore, SecurityRuleDescription } = logEntry;
  if (ClientCountry) globalStats.countryCounts.set(ClientCountry, (globalStats.countryCounts.get(ClientCountry) || 0) + 1);
  if (ClientIP) globalStats.ipCounts.set(ClientIP, (globalStats.ipCounts.get(ClientIP) || 0) + 1);
  if (ClientRequestURI) globalStats.uriCounts.set(ClientRequestURI, (globalStats.uriCounts.get(ClientRequestURI) || 0) + 1);
  if (logEntry.EdgeResponseStatus) {
    globalStats.httpStatusCounts.set(logEntry.EdgeResponseStatus, (globalStats.httpStatusCounts.get(logEntry.EdgeResponseStatus) || 0) + 1);
  }
  
  // 安全事件統計
  if (SecurityAction === 'block') globalStats.securityEvents.blockedRequests++;
  if (WAFAttackScore && WAFAttackScore >= 80) globalStats.securityEvents.highRiskRequests++;
  if (SecurityRuleDescription) {
    globalStats.securityEvents.securityRules.set(SecurityRuleDescription, 
      (globalStats.securityEvents.securityRules.get(SecurityRuleDescription) || 0) + 1);
  }
  
  // 攻擊模式分析
  if (ClientRequestURI) {
    const uri = ClientRequestURI.toLowerCase();
    
    // 敏感檔案攻擊
    if (uri.includes('.env') || uri.includes('.ds_store') || uri.includes('.git/config') || 
        uri.includes('.htaccess') || uri.includes('.htpasswd') || uri.includes('robots.txt')) {
      globalStats.attackPatterns.sensitiveFiles.set(ClientRequestURI, 
        (globalStats.attackPatterns.sensitiveFiles.get(ClientRequestURI) || 0) + 1);
    }
    
    // 管理面板攻擊
    if (uri.includes('wp-admin') || uri.includes('wp-login') || uri.includes('phpmyadmin') || 
        uri.includes('/admin') || uri.includes('administrator')) {
      globalStats.attackPatterns.adminPanels.set(ClientRequestURI, 
        (globalStats.attackPatterns.adminPanels.get(ClientRequestURI) || 0) + 1);
    }
    
    // 配置檔案攻擊
    if (uri.includes('wp-config') || uri.includes('web.config') || uri.includes('config.php') ||
        uri.includes('configuration.php') || uri.includes('settings.php')) {
      globalStats.attackPatterns.configFiles.set(ClientRequestURI, 
        (globalStats.attackPatterns.configFiles.get(ClientRequestURI) || 0) + 1);
    }
    
    // 版本控制系統攻擊
    if (uri.includes('.git/') || uri.includes('.svn/') || uri.includes('.hg/') || uri.includes('.bzr/')) {
      globalStats.attackPatterns.versionControl.set(ClientRequestURI, 
        (globalStats.attackPatterns.versionControl.get(ClientRequestURI) || 0) + 1);
    }
  }
  
  // SQL注入攻擊檢測
  if (WAFSQLiAttackScore && WAFSQLiAttackScore >= 90) {
    globalStats.attackPatterns.sqlInjection.set(ClientRequestURI || 'unknown', 
      (globalStats.attackPatterns.sqlInjection.get(ClientRequestURI || 'unknown') || 0) + 1);
  }
  
  // XSS攻擊檢測
  if (WAFXSSAttackScore && WAFXSSAttackScore >= 90) {
    globalStats.attackPatterns.xssAttempts.set(ClientRequestURI || 'unknown', 
      (globalStats.attackPatterns.xssAttempts.get(ClientRequestURI || 'unknown') || 0) + 1);
  }
}

function detectAttack(logEntry, unused, detectedAttacks) {
    const { ClientIP, EdgeStartTimestamp, ClientRequestHost, ClientRequestURI, EdgeResponseBytes, EdgeRequestHost } = logEntry;
    if (!ClientIP || !EdgeStartTimestamp) return;

    // 移除閾值判斷，直接基於每個請求來檢測潛在攻擊
    // 因為資料來源已經是經過 Cloudflare 篩選的，不需要額外的頻率閾值
    
    // 優先使用 EdgeRequestHost（Cloudflare 實際處理的域名），再使用 ClientRequestHost
    const realHost = EdgeRequestHost || ClientRequestHost || 'unknown-host';
    const clientHost = ClientRequestHost || 'unknown-host';
    
    // Debug: 記錄可能的 Host header 偽造
    if (EdgeRequestHost && ClientRequestHost && EdgeRequestHost !== ClientRequestHost) {
        console.log(`⚠️ 偵測到 Host header 可能偽造: 實際=${EdgeRequestHost}, 聲稱=${ClientRequestHost}, IP=${ClientIP}`);
    }
    
    const attackId = `${ClientIP}@${realHost}`;
    if (!detectedAttacks[attackId]) {
        detectedAttacks[attackId] = {
            attackDomain: realHost,  // 使用真實的域名
            claimedDomain: clientHost !== realHost ? clientHost : null,  // 記錄聲稱的域名
            targetURL: ClientRequestURI || '/',
            sourceList: new Map(),
            totalBytes: 0,
        };
    }
    const attack = detectedAttacks[attackId];
    attack.totalBytes += EdgeResponseBytes || 0;
    const sourceInfo = attack.sourceList.get(ClientIP) || { ip: ClientIP, count: 0, country: logEntry.ClientCountry || 'N/A', asn: logEntry.ClientASN || 'N/A' };
    sourceInfo.count++;
    attack.sourceList.set(ClientIP, sourceInfo);
}

async function getAIAssessment(requestBody) {
  const { 
    provider = 'gemini', 
    apiKey, 
    model, 
    apiUrl, // 新增支援 Ollama URL
    attackData, 
    healthData, 
    eventData, 
    overallData, 
    fieldReference, 
    owaspReferences 
  } = requestBody;

  // 根據提供商類型準備配置
  let aiConfig;
  let useModel;
  
  if (provider === 'gemini') {
    const useApiKey = apiKey || config.GEMINI_API_KEY;
    useModel = model || config.GEMINI_MODEL || 'gemini-1.5-flash';
    
    if (!useApiKey) {
      throw new Error('缺少 Gemini API Key');
    }
    
    aiConfig = { apiKey: useApiKey, model: useModel };
  } else if (provider === 'ollama') {
    const useApiUrl = apiUrl || 'http://localhost:11434';
    useModel = model;
    
    if (!useApiUrl || !useModel) {
      throw new Error('缺少 Ollama API URL 或模型名稱');
    }
    
    aiConfig = { apiUrl: useApiUrl, model: useModel };
  } else {
    throw new Error(`不支援的 AI 提供商: ${provider}`);
  }

  if (!attackData && !healthData && !eventData && !overallData) {
    throw new Error('缺少分析資料');
  }

  console.log('=== AI 分析請求 ===');
  console.log('提供商:', provider);
  console.log('使用模型:', useModel);

  const analysisId = Math.random().toString(36).substr(2, 9);
  const currentTime = new Date().toLocaleString('zh-TW');
  let prompt;

  if (attackData) {
    console.log('分析類型: 攻擊事件');
    
    // 格式化攻擊模式資訊
    const formatAttackPatterns = (patterns) => {
      const sections = [];
      if (patterns.sensitiveFiles && patterns.sensitiveFiles.length > 0) {
        sections.push(`敏感檔案探測: ${patterns.sensitiveFiles.map(p => `${p.item} (${p.count}次)`).join(', ')}`);
      }
      if (patterns.versionControl && patterns.versionControl.length > 0) {
        sections.push(`版本控制系統攻擊: ${patterns.versionControl.map(p => `${p.item} (${p.count}次)`).join(', ')}`);
      }
      if (patterns.adminPanels && patterns.adminPanels.length > 0) {
        sections.push(`管理面板攻擊: ${patterns.adminPanels.map(p => `${p.item} (${p.count}次)`).join(', ')}`);
      }
      if (patterns.configFiles && patterns.configFiles.length > 0) {
        sections.push(`配置檔案攻擊: ${patterns.configFiles.map(p => `${p.item} (${p.count}次)`).join(', ')}`);
      }
      if (patterns.sqlInjection && patterns.sqlInjection.length > 0) {
        sections.push(`SQL注入嘗試: ${patterns.sqlInjection.map(p => `${p.item} (${p.count}次)`).join(', ')}`);
      }
      if (patterns.xssAttempts && patterns.xssAttempts.length > 0) {
        sections.push(`XSS攻擊嘗試: ${patterns.xssAttempts.map(p => `${p.item} (${p.count}次)`).join(', ')}`);
      }
      return sections.length > 0 ? sections.join('\n- ') : '未檢測到其他特定攻擊模式';
    };

    // 格式化 OWASP 分析結果
    const formatOWASPFindings = (findings) => {
      if (!findings || findings.length === 0) {
        return '未檢測到特定的 OWASP 攻擊模式';
      }
      
      const sections = [];
      findings.forEach(finding => {
        finding.owaspTypes.forEach(type => {
          sections.push(`- ${type.title}: ${type.description} (匹配模式: ${type.matchedPattern})`);
        });
      });
      
      return sections.join('\n');
    };

    prompt = `你是一位專業的網路安全分析師，請分析以下DDoS攻擊事件，並提供詳細的安全評估報告。

=== 攻擊事件資訊 ===
- 攻擊目標: ${attackData.attackDomain}
- 攻擊流量: ${attackData.attackTrafficGbps.toFixed(2)} Gbps
- 攻擊來源IP數量: ${attackData.sourceList.length} 個
- 總獨立IP數: ${attackData.uniqueIPs} 個
- 總請求數: ${attackData.totalRequests.toLocaleString()} 次

${attackData.claimedDomain ? `⚠️  檢測到Host偽造攻擊：攻擊者聲稱目標為 "${attackData.claimedDomain}"，但實際攻擊 "${attackData.attackDomain}"` : ''}

=== 主要攻擊來源 ===
${attackData.sourceList.slice(0, 10).map((source, index) => 
  `${index + 1}. ${source.ip} (${source.country}) - ${source.requestCount} 次請求`
).join('\n')}

=== 攻擊模式分析 ===
- ${formatAttackPatterns(attackData.attackPatterns)}

=== 地理分佈 (前5名) ===
${attackData.topCountries.map((country, index) => `${index + 1}. ${country.item}: ${country.count} 次`).join('\n')}

${owaspReferences ? `
=== OWASP Top 10 參考資源 ===
請參考以下 OWASP Top 10 資源來分類和分析攻擊類型：
${owaspReferences.map(ref => `- ${ref}`).join('\n')}
` : ''}

=== OWASP Top 10 威脅分析 ===
${attackData.owaspFindings ? formatOWASPFindings(attackData.owaspFindings) : '未檢測到特定的 OWASP 攻擊模式'}

${attackData.attackGraph ? `
=== 攻擊關聯分析 ===
- 關聯強度: ${(attackData.attackGraph.correlationMetrics.strength * 100).toFixed(1)}%
- 多目標攻擊者: ${attackData.attackGraph.correlationMetrics.multiTargetAttackers} 個
- 基礎設施規模: ${attackData.attackGraph.correlationMetrics.infrastructureScope} 個域名

=== IP 集群分析 ===
${attackData.attackGraph.ipClusters.slice(0, 5).map((cluster, index) => 
  `${index + 1}. ${cluster.ip} [${cluster.riskLevel}]\n   - 攻擊目標: ${cluster.targets.length} 個\n   - 攻擊技術: ${cluster.techniques.join(', ')}`
).join('\n')}

=== 域名基礎設施分析 ===
${attackData.attackGraph.infrastructureMap.slice(0, 3).map((infra, index) => 
  `${index + 1}. ${infra.baseDomain}\n   - 子域名: ${infra.subdomains.length} 個\n   - 攻擊者: ${infra.attackers.length} 個`
).join('\n')}
` : ''}

請以專業角度提供分析報告，格式如下：

**事件概述**
[提供100-150字的事件概述]

**威脅等級評估**
[評估威脅等級：高/中/低，並說明原因]

**攻擊手法分析**
[分析具體的攻擊手法和技術]

**具體防禦建議**
[提供至少5項具體可行的防禦建議]

**後續監控重點**
[說明需要重點監控的項目]

請用繁體中文回應，使用上述 Markdown 格式，確保建議具體可行。`;

  } else if (healthData || eventData) {
    console.log('分析類型: 事件型分析');
    const data = healthData || eventData;
    
    prompt = `你是一位專業的網路安全分析師，請分析以下網路安全事件，並提供詳細的安全評估報告。

=== 系統健康狀況 ===
- 總請求數: ${data.totalRequests.toLocaleString()} 次
- 獨立IP數量: ${data.uniqueIPs} 個
- 時間範圍: ${data.timeRange ? `${data.timeRange.start} 到 ${data.timeRange.end}` : '未指定'}

=== 安全事件統計 ===
- 被阻擋請求: ${data.securityEvents.blockedRequests} 次
- 高風險請求: ${data.securityEvents.highRiskRequests} 次
- 觸發的安全規則:
${data.securityEvents.topSecurityRules.map((rule, index) => `  ${index + 1}. ${rule.item}: ${rule.count} 次`).join('\n')}

=== OWASP Top 10 威脅分析 ===
${data.owaspFindings ? formatOWASPFindings(data.owaspFindings) : '未檢測到特定的 OWASP 攻擊模式'}

請以專業角度提供分析報告，格式如下：

**系統安全狀態概述**
[概述當前系統的整體安全狀況]

**潛在威脅評估**
[評估識別出的潛在威脅和風險]

**安全改進建議**
[提供具體的安全改進建議]

**預防措施建議**
[建議具體的預防措施]

請用繁體中文回應，使用上述 Markdown 格式。`;

  } else if (overallData) {
    console.log('分析類型: 整體綜合分析');
    
    prompt = `你是一位專業的網路安全分析師，請分析以下整體網路流量資料，並提供綜合的安全評估報告。

=== 整體流量概況 ===
- 總請求數: ${overallData.totalRequests.toLocaleString()} 次
- 獨立IP數量: ${overallData.uniqueIPs} 個
- 時間範圍: ${overallData.timeRange ? `${overallData.timeRange.start} 到 ${overallData.timeRange.end}` : '未指定'}

=== 安全事件統計 ===
- 被阻擋請求: ${overallData.securityEvents.blockedRequests} 次
- 高風險請求: ${overallData.securityEvents.highRiskRequests} 次

=== OWASP Top 10 威脅分析 ===
${overallData.owaspFindings ? formatOWASPFindings(overallData.owaspFindings) : '未檢測到特定的 OWASP 攻擊模式'}

請以專業角度提供分析報告，格式如下：

**整體安全狀況評估**
[評估系統的整體安全狀況]

**流量模式分析**
[分析網路流量的模式和特徵]

**潛在風險識別**
[識別和評估潛在的安全風險]

**安全策略建議**
[提供具體的安全策略建議]

請用繁體中文回應，使用上述 Markdown 格式。`;
  }

  try {
    const startTime = Date.now();
    
    // 使用 AI 提供商管理器生成內容
    const result = await aiProviderManager.generateContent(provider, aiConfig, prompt);
    
    const responseTime = Date.now() - startTime;
    console.log(`✅ ${provider} AI 分析完成，耗時 ${responseTime}ms`);

    // 解析回應內容
    let summary, recommendations;
    const responseText = result.text;
    
    // 強健的 AI 回覆解析策略 - 處理各種空白字符和換行符變化
    
    // 智能概述解析：支援多種標題格式
    let summaryMatch = responseText.match(/(?:\*\*事件概述\*\*|###?\s*事件概述)[\s\n]*(.+?)(?=[\s\n]*(?:\*\*(?:威脅等級評估|攻擊手法分析)|###?\s*(?:威脅等級評估|攻擊手法分析)))/s);
    if (!summaryMatch) {
      // 備用匹配：其他概述格式
      summaryMatch = responseText.match(/(?:\*\*(?:系統安全狀態概述|整體安全狀況評估)\*\*|###?\s*(?:系統安全狀態概述|整體安全狀況評估))[\s\n]*(.+?)(?=[\s\n]*(?:\*\*|###?\s*))/s);
    }
    if (!summaryMatch) {
      // 第三層匹配：編號格式
      summaryMatch = responseText.match(/(?:1\.\s*(?:事件概述|系統安全狀態概述|整體安全狀況評估)[：:]\s*)(.+?)(?=\n(?:2\.|$))/s);
    }
    
    // 智能建議解析：支援多種標題格式
    let recommendationsMatch = responseText.match(/(?:\*\*(?:防禦建議|具體防禦建議)\*\*|###?\s*(?:防禦建議|具體防禦建議))[\s\n]*(.+?)(?=[\s\n]*(?:\*\*(?:後續監控重點)|###?\s*(?:後續監控重點)|$))/s);
    if (!recommendationsMatch) {
      // 備用匹配：其他建議格式
      recommendationsMatch = responseText.match(/(?:\*\*(?:安全改進建議|預防措施建議|安全策略建議)\*\*|###?\s*(?:安全改進建議|預防措施建議|安全策略建議))[\s\n]*(.+?)(?=[\s\n]*(?:\*\*|###?\s*))/s);
    }
    if (!recommendationsMatch) {
      // 第三層匹配：編號格式
      recommendationsMatch = responseText.match(/(?:4\.\s*(?:防禦建議|具體防禦建議|安全改進建議)[：:])(.+?)(?=\n(?:5\.|$))/s);
    }
    
          if (summaryMatch) {
        // 清理 summary，移除不必要的標題和格式
        let cleanedSummary = summaryMatch[1].trim();
        
        // 移除可能包含的標題標記
        cleanedSummary = cleanedSummary.replace(/^\*\*[^*]+\*\*\s*\n?\s*/, '');
        
        // 確保內容足夠長且有意義
        if (cleanedSummary.length > 50) {
          summary = cleanedSummary;
          console.log('✅ 成功解析事件概述，長度:', summary.length);
        } else {
          // 如果解析結果太短，使用 fallback
          summary = responseText.substring(0, 800) + (responseText.length > 800 ? '...' : '');
          console.log('⚠️ 解析結果太短，使用 fallback 概述，長度:', summary.length);
        }
      } else {
        // 增加 fallback 字元限制，從 200 提升到 800
        summary = responseText.substring(0, 800) + (responseText.length > 800 ? '...' : '');
        console.log('⚠️ 使用 fallback 概述，長度:', summary.length);
      }
    
          if (recommendationsMatch) {
        // 改進的建議解析邏輯 - 處理實際的 AI 回覆格式
        const rawRecommendations = recommendationsMatch[1]
          .split(/\n/)
          .filter(line => line.trim())
          .map(line => {
            // 處理編號格式 (1. **標題**：內容)
            let cleaned = line.replace(/^\d+\.\s*/, ''); // 移除編號
            cleaned = cleaned.replace(/\*\*([^*]+)\*\*[：:]\s*(.+)/, '$1: $2'); // 處理標題格式
            cleaned = cleaned.replace(/\*\*([^*]+)\*\*/, '$1'); // 移除剩餘的 **
            return cleaned.trim();
          })
          .filter(line => line.length > 10); // 過濾太短的行
        
        recommendations = rawRecommendations.length > 0 ? rawRecommendations : 
          ['建議加強網路安全監控', '實施多層防護策略', '定期更新安全政策'];
        
        console.log('✅ 成功解析防禦建議，數量:', recommendations.length);
        console.log('📋 建議內容:', recommendations.slice(0, 2).map(r => r.substring(0, 50) + '...'));
      } else {
        recommendations = ['建議加強網路安全監控', '實施多層防護策略', '定期更新安全政策'];
        console.log('⚠️ 使用預設防禦建議');
      }

    return {
      summary: summary,
      recommendations: recommendations,
      fullResponse: responseText,
      metadata: {
        analysisId: analysisId,
        timestamp: currentTime,
        provider: provider,
        model: useModel,
        responseTime: responseTime,
        isAIGenerated: true
      }
    };
    
  } catch (error) {
    console.error(`${provider} AI 分析失敗:`, error);
    
    // 提供後備回應
    const fallbackSummary = attackData 
      ? `檢測到針對 ${attackData.attackDomain} 的 DDoS 攻擊，攻擊流量達 ${attackData.attackTrafficGbps.toFixed(2)} Gbps，來源IP數量 ${attackData.sourceList.length} 個。建議立即啟動防護措施。`
      : '檢測到網路安全異常活動，建議加強監控並檢查安全配置。';
      
    return {
      summary: fallbackSummary,
      recommendations: [
        '立即啟動 DDoS 防護機制',
        '封鎖可疑來源 IP 地址',
        '加強流量監控和分析',
        '檢查並更新安全規則',
        '準備應急響應計劃'
      ],
      fullResponse: `AI 分析服務暫時不可用，以下為基於資料的基本分析：\n\n${fallbackSummary}`,
      metadata: {
        analysisId: analysisId,
        timestamp: currentTime,
        provider: provider,
        model: useModel,
        responseTime: 0,
        isAIGenerated: false,
        error: error.message
      }
    };
  }
}

// === ELK 資料處理函數 ===

// 處理來自 ELK 的日誌資料
async function processELKLogs(config) {
  const { apiKey, model, timeRange, startTime, endTime } = config;
  
  try {
    if (startTime && endTime) {
      console.log(`🔍 開始處理 ELK 日誌資料 (自定義時間範圍: ${startTime} 到 ${endTime})...`);
    } else {
      console.log(`🔍 開始處理 ELK 日誌資料 (時間範圍: ${timeRange})...`);
    }
    
    // 確保ELK連接狀態
    console.log('🔄 確保 ELK MCP 連接狀態...');
    await elkMCPClient.ensureConnection();
    console.log('✅ ELK MCP 連接確認完成');
    
    // 從 ELK 獲取日誌資料
    let elkData;
    try {
      // 如果有自定義時間範圍，使用自定義查詢方法
      if (startTime && endTime) {
        elkData = await elkMCPClient.queryElasticsearchCustomTime(startTime, endTime);
      } else {
        elkData = await elkMCPClient.queryElasticsearch(timeRange);
      }
    } catch (queryError) {
      console.error('❌ ELK 查詢執行失敗:', queryError);
      throw new Error(`ELK 查詢失敗: ${queryError.message}。請檢查 ELK 配置或網路連接。`);
    }
    
    if (!elkData) {
      throw new Error('ELK 查詢返回空結果，請檢查 Elasticsearch 服務狀態');
    }
    
    if (!elkData.hits || elkData.hits.length === 0) {
      console.log('⚠️  未找到日誌資料');
      return {
        summary: '在指定時間範圍內未找到任何日誌資料',
        recommendations: ['請檢查時間範圍設定或確認 ELK 中是否有資料'],
        metadata: {
          analysisId: generateAnalysisId(),
          timestamp: new Date().toISOString(),
          dataSource: 'elk',
          recordCount: 0
        },
        // 為攻擊來源統計提供空資料
        topIPs: [],
        topCountries: [],
        topURIs: [],
        topDomains: [],
        wafScoreStats: [],
        globalStats: { httpStatusCounts: new Map() },
      };
    }
    
    console.log(`📊 成功獲取 ${elkData.hits.length} 筆日誌記錄`);
    
    // 轉換 ELK 資料格式為現有處理邏輯可用的格式
    const validHits = elkData.hits.filter(hit => hit && hit.source && hit.source["@timestamp"]);
    console.log(`🔍 過濾後有效記錄數: ${validHits.length}/${elkData.hits.length}`);
    
    const logEntries = validHits
      .map(hit => convertELKToLogEntry(hit.source))
      .filter(entry => entry !== null); // 過濾掉轉換失敗的記錄
    
    console.log(`✅ 成功轉換記錄數: ${logEntries.length}/${validHits.length}`);
    
    if (logEntries.length === 0) {
      console.warn('⚠️ 沒有有效的日誌記錄可供分析');
      throw new Error('沒有有效的日誌記錄可供分析');
    }
    
    // 使用現有的統計和攻擊檢測邏輯
    const { globalStats, detectedAttacks } = await analyzeLogEntries(logEntries);
    
    // 整合 OWASP 攻擊類型識別
    const owaspAnalysis = analyzeOWASPPatterns(logEntries);
    
    // 決定分析類型並執行 AI 分析
    if (Object.keys(detectedAttacks).length > 0) {
      // 攻擊事件分析 - 選擇最嚴重的攻擊進行詳細分析
      let selectedAttack = null;
      let maxScore = 0;
      
      // 準備所有攻擊的摘要
      const allAttacks = Object.entries(detectedAttacks).map(([id, attack]) => ({
        id: id,
        domain: attack.attackDomain,
        claimedDomain: attack.claimedDomain,
        sourceCount: attack.sourceList.size,
        targetURL: attack.targetURL,
        severity: calculateAttackSeverity(attack)
      }));
      
      // 選擇最嚴重的攻擊
      for (const [attackId, attack] of Object.entries(detectedAttacks)) {
        const attackScore = calculateAttackSeverity(attack);
        if (attackScore > maxScore) {
          maxScore = attackScore;
          selectedAttack = attack;
        }
      }
      
      const attackData = buildAttackData(selectedAttack, globalStats, owaspAnalysis, allAttacks);
      
      console.log('\n🔗 攻擊關聯圖摘要:');
      if (attackData.attackGraph) {
        console.log(`關聯強度: ${(attackData.attackGraph.correlationMetrics.strength * 100).toFixed(1)}%`);
        console.log(`多目標攻擊者: ${attackData.attackGraph.correlationMetrics.multiTargetAttackers} 個`);
        console.log(`基礎設施規模: ${attackData.attackGraph.correlationMetrics.infrastructureScope} 個子域名`);
        console.log('IP集群:');
        attackData.attackGraph.ipClusters.forEach((cluster, index) => {
          console.log(`  ${index + 1}. ${cluster.ip} [${cluster.riskLevel}] - 目標: ${cluster.targets.length}, 技術: ${cluster.techniques.join(', ')}`);
        });
      } else {
        console.log('無關聯圖資料');
      }
      
      const aiAnalysis = await getAIAssessment({ 
        ...config, 
        attackData,
        fieldReference: generateAIFieldReference(),
        owaspReferences: OWASP_REFERENCES.mainReferences
      });
      
      return { 
        ...aiAnalysis, 
        attackData,
        wafScoreData: globalStats.wafScoreData || [],
        globalStats,
      };
    } else if (globalStats.totalBytes === 0 || (globalStats.totalBytes / globalStats.totalRequests) < 100) {
      // 事件型日誌分析
      const eventData = buildEventData(globalStats, owaspAnalysis);
      const aiAnalysis = await getAIAssessment({ 
        ...config, 
        eventData,
        fieldReference: generateAIFieldReference(),
        owaspReferences: OWASP_REFERENCES.mainReferences
      });
      
      return { 
        ...aiAnalysis, 
        wafScoreData: globalStats.wafScoreData || [],
        globalStats,
      };
    } else {
      // 整體綜合分析
      const overallData = buildOverallData(globalStats, owaspAnalysis);
      const aiAnalysis = await getAIAssessment({ 
        ...config, 
        overallData,
        fieldReference: generateAIFieldReference(),
        owaspReferences: OWASP_REFERENCES.mainReferences
      });
      
      return { 
        ...aiAnalysis, 
        wafScoreData: globalStats.wafScoreData || [],
        globalStats,
      };
    }
    
  } catch (error) {
    console.error('❌ ELK 日誌處理失敗:', error);
    console.error('錯誤堆疊:', error.stack);
    throw error;
  }
}

// 將 ELK 資料轉換為現有日誌格式
function convertELKToLogEntry(elkRecord) {
  try {
    // 檢查必要字段是否存在
    if (!elkRecord || !elkRecord["@timestamp"]) {
      console.warn('⚠️ ELK記錄缺少必要的@timestamp字段，跳過此記錄');
      return null;
    }

    return {
      timestamp: elkRecord["@timestamp"],
      EdgeStartTimestamp: elkRecord["EdgeStartTimestamp"] || elkRecord["@timestamp"], // 使用 EdgeStartTimestamp 或 @timestamp
      ClientIP: elkRecord["ClientIP"] || 'unknown',
      ClientCountry: elkRecord["ClientCountry"] || 'unknown',
      ClientASN: elkRecord["ClientASN"] || 'unknown',
      EdgeRequestHost: elkRecord["EdgeRequestHost"] || '', // Cloudflare 實際處理的域名
      ClientRequestHost: elkRecord["ClientRequestHost"] || '', // 客戶端聲稱的域名
      ClientRequestURI: elkRecord["ClientRequestURI"] || '/',
      EdgeResponseBytes: elkRecord["EdgeResponseBytes"] || 0,
      ClientRequestBytes: elkRecord["ClientRequestBytes"] || 0, // 新增：客戶端請求位元組數
      EdgeResponseStatus: elkRecord["EdgeResponseStatus"] || 0,
      SecurityAction: elkRecord["SecurityAction"] || '',
      SecurityRuleDescription: elkRecord["SecurityRuleDescription"] || '',
      WAFAttackScore: elkRecord["WAFAttackScore"] || 0,
      WAFSQLiAttackScore: elkRecord["WAFSQLiAttackScore"] || 0,
      WAFXSSAttackScore: elkRecord["WAFXSSAttackScore"] || 0,
      WAFRCEAttackScore: elkRecord["WAFRCEAttackScore"] || 0, // 添加 RCE 攻擊分數
      ClientRequestUserAgent: elkRecord["ClientRequestUserAgent"] || '',
      RayID: elkRecord["RayID"] || ''
    };
  } catch (error) {
    console.error('❌ ELK記錄轉換失敗:', error);
    return null;
  }
}

// 分析日誌條目（重構現有邏輯以支援重用）
async function analyzeLogEntries(logEntries) {
  // 初始化統計資料
  const globalStats = {
    totalRequests: 0,
    totalBytes: 0,
    uniqueIPs: new Set(),
    countryCounts: new Map(),
    ipCounts: new Map(),
    uriCounts: new Map(),
    httpStatusCounts: new Map(),
    firstTimestamp: null,
    lastTimestamp: null,
    timeRange: null, // 將在處理過程中設定
    securityEvents: {
      blockedRequests: 0,
      highRiskRequests: 0,
      wafTriggers: 0,
      securityRules: new Map()
    },
    attackPatterns: {
      sensitiveFiles: new Map(),
      adminPanels: new Map(),
      configFiles: new Map(),
      versionControl: new Map(),
      sqlInjection: new Map(),
      xssAttempts: new Map()
    }
  };

  const detectedAttacks = {};

  // 處理每個日誌條目
  for (const entry of logEntries) {
    updateGlobalStats(entry, globalStats);
    detectAttack(entry, null, detectedAttacks); // 不再需要 ipRequestTimes
  }

  // 設定時間範圍
  if (globalStats.firstTimestamp && globalStats.lastTimestamp) {
    globalStats.timeRange = {
      start: new Date(globalStats.firstTimestamp).toISOString(),
      end: new Date(globalStats.lastTimestamp).toISOString()
    };
  }

  return { globalStats, detectedAttacks };
}

// OWASP 攻擊模式分析
function analyzeOWASPPatterns(logEntries) {
  const owaspFindings = [];
  
  for (const entry of logEntries) {
    const uri = entry.ClientRequestURI || '';
    const userAgent = entry.ClientRequestUserAgent || '';
    const securityRules = entry.SecurityRuleDescription || '';
    
    // 識別 OWASP 攻擊類型
    const detectedTypes = identifyOWASPType(uri, userAgent, securityRules);
    
    if (detectedTypes.length > 0) {
      owaspFindings.push({
        rayId: entry.RayID,
        clientIp: entry.ClientIP,
        uri: uri,
        userAgent: userAgent,
        timestamp: entry.timestamp,
        owaspTypes: detectedTypes,
        wafScore: entry.WAFAttackScore
      });
    }
  }
  
  return owaspFindings;
}

// 建立攻擊資料結構（包含 OWASP 分析和關聯圖）
function buildAttackData(attack, globalStats, owaspAnalysis, allAttacks = null) {
  const getTop5 = (map) => Array.from(map.entries())
    .sort(([, a], [, b]) => b - a)
    .slice(0, 5)
    .map(([key, value]) => ({ item: key, count: value }));

  // 建立攻擊關聯圖
  const attackGraph = buildAttackRelationshipGraph(allAttacks || []);

  return {
    attackDomain: attack.attackDomain,
    claimedDomain: attack.claimedDomain,  // 包含可能偽造的域名
    targetIP: "N/A",
    targetURL: attack.targetURL,
    attackTrafficGbps: (attack.totalBytes * 8) / (TIME_WINDOW_SECONDS * 1e9),
    sourceList: Array.from(attack.sourceList.values()),
    // 包含所有攻擊的摘要資訊
    allAttacks: allAttacks || null,
    // 新增：攻擊關聯圖
    attackGraph: attackGraph,
    // 基本統計
    totalRequests: globalStats.totalRequests,
    uniqueIPs: globalStats.uniqueIPs.size,
    timeRange: {
      start: globalStats.firstTimestamp ? globalStats.firstTimestamp.toISOString() : 'N/A',
      end: globalStats.lastTimestamp ? globalStats.lastTimestamp.toISOString() : 'N/A',
    },
    // 安全事件統計
    securityEvents: {
      blockedRequests: globalStats.securityEvents.blockedRequests,
      highRiskRequests: globalStats.securityEvents.highRiskRequests,
      topSecurityRules: getTop5(globalStats.securityEvents.securityRules),
    },
    // 攻擊模式分析
    attackPatterns: {
      sensitiveFiles: getTop5(globalStats.attackPatterns.sensitiveFiles),
      adminPanels: getTop5(globalStats.attackPatterns.adminPanels),
      configFiles: getTop5(globalStats.attackPatterns.configFiles),
      versionControl: getTop5(globalStats.attackPatterns.versionControl),
      sqlInjection: getTop5(globalStats.attackPatterns.sqlInjection),
      xssAttempts: getTop5(globalStats.attackPatterns.xssAttempts),
    },
    // 地理和IP分佈
    topCountries: getTop5(globalStats.countryCounts),
    topIPs: getTop5(globalStats.ipCounts),
    topURIs: getTop5(globalStats.uriCounts),
    // OWASP 分析結果
    owaspFindings: owaspAnalysis
  };
}

// 建立事件資料結構
function buildEventData(globalStats, owaspAnalysis) {
  const getTop5 = (map) => {
    if (!map || typeof map.entries !== 'function') return [];
    return Array.from(map.entries())
      .sort(([, a], [, b]) => b - a)
      .slice(0, 5)
      .map(([key, value]) => ({ item: key, count: value }));
  };

  return {
    totalRequests: globalStats.totalRequests,
    uniqueIPs: globalStats.uniqueIPs.size,
    topCountries: getTop5(globalStats.countryCounts),
    topIPs: getTop5(globalStats.ipCounts),
    topURIs: getTop5(globalStats.uriCounts),
    securityEvents: {
      ...globalStats.securityEvents,
      topSecurityRules: getTop5(globalStats.securityEvents.securityRules)
    },
    attackPatterns: {
      sensitiveFiles: getTop5(globalStats.attackPatterns.sensitiveFiles),
      adminPanels: getTop5(globalStats.attackPatterns.adminPanels),
      configFiles: getTop5(globalStats.attackPatterns.configFiles),
      versionControl: getTop5(globalStats.attackPatterns.versionControl),
      sqlInjection: getTop5(globalStats.attackPatterns.sqlInjection),
      xssAttempts: getTop5(globalStats.attackPatterns.xssAttempts),
      rceAttempts: getTop5(globalStats.attackPatterns.rceAttempts)
    },
    owaspFindings: owaspAnalysis,
    timeRange: globalStats.timeRange || { start: 'N/A', end: 'N/A' }
  };
}

// 建立整體資料結構
function buildOverallData(globalStats, owaspAnalysis) {
  return buildEventData(globalStats, owaspAnalysis); // 相同結構
}


// === 新增 ELK 相關 API 端點 ===

// ELK 連接測試端點
app.get('/api/elk/test-connection', async (req, res) => {
  try {
    const isConnected = await elkMCPClient.testConnection();
    res.json({ 
      connected: isConnected,
      message: isConnected ? 'ELK MCP 連接正常' : 'ELK MCP 連接失敗'
    });
  } catch (error) {
    res.status(500).json({ 
      connected: false, 
      error: error.message 
    });
  }
});

// ELK 資料來源分析端點
app.post('/api/analyze-elk-log', async (req, res) => {
  try {
    const { apiKey, model, timeRange = '1h', dataSource = 'file' } = req.body;
    
    if (!apiKey) {
      return res.status(400).json({ error: 'API key is required' });
    }

    let analysisResult;

    if (dataSource === 'elk') {
      // 使用 ELK 作為資料來源
      console.log('🔍 使用 ELK 資料來源進行分析...');
      analysisResult = await processELKLogs({ apiKey, model, timeRange });
    } else {
      // 使用檔案作為資料來源（保持向後相容）
      console.log('📁 使用檔案資料來源進行分析...');
      analysisResult = await processLogFile({ apiKey, model });
    }

    res.json(analysisResult);
  } catch (error) {
    console.error('分析錯誤:', error);
    res.status(500).json({ 
      error: '分析失敗', 
      details: error.message 
    });
  }
});

// 獲取 ELK 統計資料
app.get('/api/elk/stats/:timeRange', async (req, res) => {
  try {
    const timeRange = req.params.timeRange || '1h';
    const stats = await elkMCPClient.getSecurityStats(timeRange);
    res.json(stats);
  } catch (error) {
    res.status(500).json({ 
      error: '獲取統計資料失敗', 
      details: error.message 
    });
  }
});

// 獲取 ELK 統計資料（無參數版本）
app.get('/api/elk/stats', async (req, res) => {
  try {
    const timeRange = '1h';
    const stats = await elkMCPClient.getSecurityStats(timeRange);
    res.json(stats);
  } catch (error) {
    res.status(500).json({ 
      error: '獲取統計資料失敗', 
      details: error.message 
    });
  }
});

// === 攻擊趨勢對比分析 API ===

// 載入趨勢對比資料
app.post('/api/load-trend-comparison', async (req, res) => {
  const { timeRange } = req.body;
  
  try {
    console.log(`🔍 開始載入趨勢對比資料 (時間範圍: ${timeRange})...`);
    
    // 計算對比時間區間
    const periods = trendAnalysisService.calculateComparisonPeriods(timeRange);
    
    console.log(`當前時期: ${periods.current.start.toISOString()} - ${periods.current.end.toISOString()}`);
    console.log(`上一時期: ${periods.previous.start.toISOString()} - ${periods.previous.end.toISOString()}`);

    // 進度追蹤回調
    const progressUpdates = [];
    const progressCallback = (update) => {
      progressUpdates.push({
        ...update,
        timestamp: new Date().toISOString()
      });
      console.log(`📋 查詢進度: ${update.description || update.type} - ${update.batchIndex}/${update.totalBatches}`);
    };

    // 查詢實際ELK資料並分割為兩個時期
    const allLogData = await queryActualELKData(timeRange, 0, progressCallback);
    
    if (allLogData.length === 0) {
      throw new Error('未找到任何日誌資料，請檢查ELK連接或數據範圍');
    }

    // 將資料按時間排序並分割為兩個相等時期
    const sortedData = allLogData.sort((a, b) => 
      new Date(a.EdgeStartTimestamp || a.timestamp) - new Date(b.EdgeStartTimestamp || b.timestamp)
    );
    
    const midpoint = Math.floor(sortedData.length / 2);
    const previousData = sortedData.slice(0, midpoint);
    const currentData = sortedData.slice(midpoint);
    
    // 計算實際時間範圍
    const actualPeriods = calculateActualPeriods(previousData, currentData, timeRange);

    console.log(`✅ 數據分割完成:`);
    console.log(`上一時期: ${previousData.length} 筆記錄 (${actualPeriods.previous.start} - ${actualPeriods.previous.end})`);
    console.log(`當前時期: ${currentData.length} 筆記錄 (${actualPeriods.current.start} - ${actualPeriods.current.end})`);

    // 基於ClientRequestBytes生成流量統計
    const currentAnalysis = trendAnalysisService.analyzePeriodTraffic(currentData, actualPeriods.current);
    const previousAnalysis = trendAnalysisService.analyzePeriodTraffic(previousData, actualPeriods.previous);
    
    // 生成單一對比圖表資料
    const comparisonChart = trendAnalysisService.generateTrafficComparisonChart(
      currentAnalysis, 
      previousAnalysis, 
      actualPeriods
    );

    // 計算對比統計
    const statistics = trendAnalysisService.calculateComparisonStats(currentAnalysis, previousAnalysis);

    console.log(`✅ 趨勢對比資料載入完成`);
    console.log(`當前時期: ${currentAnalysis.totalRequests} 次請求, ${trendAnalysisService.formatBytes(currentAnalysis.totalRequestTraffic)} 流量`);
    console.log(`上一時期: ${previousAnalysis.totalRequests} 次請求, ${trendAnalysisService.formatBytes(previousAnalysis.totalRequestTraffic)} 流量`);

    res.json({
      success: true,
      periods: actualPeriods,
      currentPeriod: currentAnalysis,
      previousPeriod: previousAnalysis,
      comparisonChart,
      statistics,
      queryInfo: {
        totalBatches: progressUpdates.length > 0 ? progressUpdates[progressUpdates.length - 1].totalBatches : 1,
        successfulBatches: progressUpdates.filter(p => p.type === 'batch_complete' && p.success).length,
        failedBatches: progressUpdates.filter(p => p.type === 'batch_error').length,
        totalRecords: allLogData.length,
        queryMethod: progressUpdates.length > 1 ? 'batch' : 'single',
        progressLog: progressUpdates
      }
    });

  } catch (error) {
    console.error('❌ 趨勢資料載入失敗:', error);
    
    // 提供更詳細的錯誤信息
    const errorResponse = { 
      error: error.message,
      details: '趨勢對比資料載入失敗',
      timeRange: timeRange
    };
    
    // 如果有進度信息，也包含在錯誤響應中
    if (progressUpdates && progressUpdates.length > 0) {
      errorResponse.queryInfo = {
        totalBatches: progressUpdates[progressUpdates.length - 1]?.totalBatches || 0,
        completedBatches: progressUpdates.filter(p => p.type === 'batch_complete').length,
        failedBatches: progressUpdates.filter(p => p.type === 'batch_error').length,
        progressLog: progressUpdates
      };
    }
    
    res.status(500).json(errorResponse);
  }
});

// AI 趨勢分析
app.post('/api/analyze-attack-trends', async (req, res) => {
  const { apiKey, model, currentData, previousData, periods } = req.body;
  
  try {
    console.log('🤖 開始 AI 趨勢分析...');
    
    if (!apiKey) {
      throw new Error('請先在「AI分析設定」頁面設定 Gemini API Key');
    }
    
    if (!currentData || !previousData) {
      throw new Error('請先載入趨勢圖表資料');
    }

    // 建構AI分析提示詞
    const analysisPrompt = trendAnalysisService.buildTrendAnalysisPrompt(currentData, previousData, periods);
    
    console.log('📝 生成 AI 分析提示詞...');
    
    // 調用Gemini AI分析
    const genAI = new GoogleGenerativeAI(apiKey);
    const geminiModel = genAI.getGenerativeModel({ model: model || 'gemini-1.5-pro' });
    
    const result = await geminiModel.generateContent(analysisPrompt);
    const response = await result.response;
    const trendAnalysis = response.text();

    console.log('✅ AI 趨勢分析完成');

    res.json({
      success: true,
      trendAnalysis,
      metadata: {
        analysisId: generateAnalysisId(),
        timestamp: new Date().toISOString(),
        model: model || 'gemini-1.5-pro',
        isAIGenerated: true,
        analysisType: 'traffic_trend_comparison'
      }
    });

  } catch (error) {
    console.error('❌ AI趨勢分析失敗:', error);
    res.status(500).json({ 
      error: error.message,
      details: 'AI趨勢分析失敗'
    });
  }
});

// === 分批查詢策略實施 ===

// 智能時間分割函數
function splitTimeRangeForBatchQuery(timeRange) {
  const strategies = {
    '1h': { batchSize: '30m', maxBatches: 2 },
    '6h': { batchSize: '2h', maxBatches: 3 },
    '1d': { batchSize: '6h', maxBatches: 4 },
    '3d': { batchSize: '1d', maxBatches: 3 },
    '7d': { batchSize: '1d', maxBatches: 7 },
    '30d': { batchSize: '3d', maxBatches: 10 }
  };

  const strategy = strategies[timeRange] || { batchSize: '1d', maxBatches: 3 };
  
  console.log(`📊 時間分割策略: ${timeRange} → ${strategy.maxBatches}個 ${strategy.batchSize} 批次`);
  
  return strategy;
}

// 計算時間範圍的毫秒數
function parseTimeRangeToMs(timeRange) {
  const unit = timeRange.slice(-1);
  const value = parseInt(timeRange.slice(0, -1));
  
  const multipliers = {
    'm': 60 * 1000,
    'h': 60 * 60 * 1000,
    'd': 24 * 60 * 60 * 1000
  };
  
  return value * (multipliers[unit] || multipliers['h']);
}

// 生成分批時間段
function generateTimeBatches(timeRange) {
  const strategy = splitTimeRangeForBatchQuery(timeRange);
  const now = new Date();
  const totalMs = parseTimeRangeToMs(timeRange);
  const batchMs = parseTimeRangeToMs(strategy.batchSize);
  
  const batches = [];
  let currentEnd = now;
  
  for (let i = 0; i < strategy.maxBatches; i++) {
    const currentStart = new Date(currentEnd.getTime() - batchMs);
    
    // 確保不超過總時間範圍
    if (now.getTime() - currentStart.getTime() > totalMs) {
      const adjustedStart = new Date(now.getTime() - totalMs);
      if (adjustedStart.getTime() < currentEnd.getTime()) {
        batches.push({
          start: adjustedStart,
          end: currentEnd,
          batchIndex: i + 1,
          totalBatches: strategy.maxBatches,
          description: `批次 ${i + 1}/${strategy.maxBatches}`
        });
      }
      break;
    }
    
    batches.push({
      start: currentStart,
      end: currentEnd,
      batchIndex: i + 1,
      totalBatches: strategy.maxBatches,
      description: `批次 ${i + 1}/${strategy.maxBatches}`
    });
    
    currentEnd = currentStart;
  }
  
  // 反轉順序，從最早的時間開始
  batches.reverse();
  batches.forEach((batch, index) => {
    batch.batchIndex = index + 1;
    batch.description = `批次 ${index + 1}/${batches.length}`;
  });
  
  return batches;
}

// 分批查詢ELK數據
async function queryELKDataInBatches(timeRange, progressCallback = null) {
  console.log(`🚀 開始分批查詢 ELK 數據 (時間範圍: ${timeRange})`);
  
  // 檢查是否需要分批查詢
  const shouldUseBatch = ['3d', '7d', '30d'].includes(timeRange);
  
  if (!shouldUseBatch) {
    console.log(`📝 時間範圍 ${timeRange} 無需分批，使用原始查詢`);
    return await querySingleBatch(timeRange, 1, 1, progressCallback);
  }
  
  const batches = generateTimeBatches(timeRange);
  const allResults = [];
  let successCount = 0;
  let partialFailures = [];
  
  console.log(`📋 生成 ${batches.length} 個查詢批次:`);
  batches.forEach(batch => {
    console.log(`  ${batch.description}: ${batch.start.toISOString()} - ${batch.end.toISOString()}`);
  });
  
  for (const batch of batches) {
    try {
      if (progressCallback) {
        progressCallback({
          type: 'batch_start',
          batchIndex: batch.batchIndex,
          totalBatches: batch.totalBatches,
          description: batch.description,
          timeRange: `${batch.start.toISOString()} - ${batch.end.toISOString()}`
        });
      }
      
      console.log(`🔍 執行 ${batch.description} 查詢...`);
      console.log(`   時間範圍: ${batch.start.toISOString()} - ${batch.end.toISOString()}`);
      
      const batchResult = await queryCustomTimeRangeBatch(batch.start, batch.end, batch.batchIndex, batch.totalBatches);
      
      if (batchResult && batchResult.length > 0) {
        allResults.push(...batchResult);
        successCount++;
        console.log(`✅ ${batch.description} 查詢成功，獲得 ${batchResult.length} 筆記錄`);
      } else {
        console.log(`⚠️ ${batch.description} 查詢無數據`);
      }
      
      if (progressCallback) {
        progressCallback({
          type: 'batch_complete',
          batchIndex: batch.batchIndex,
          totalBatches: batch.totalBatches,
          recordCount: batchResult ? batchResult.length : 0,
          success: true
        });
      }
      
    } catch (error) {
      console.error(`❌ ${batch.description} 查詢失敗:`, error.message);
      partialFailures.push({
        batch: batch.description,
        error: error.message,
        timeRange: `${batch.start.toISOString()} - ${batch.end.toISOString()}`
      });
      
      if (progressCallback) {
        progressCallback({
          type: 'batch_error',
          batchIndex: batch.batchIndex,
          totalBatches: batch.totalBatches,
          error: error.message
        });
      }
      
      // 如果是超時錯誤，繼續嘗試其他批次
      if (error.message.includes('timeout') || error.message.includes('timed out')) {
        console.log(`⏭️ 跳過超時的批次，繼續處理剩餘批次...`);
        continue;
      }
      
      // 其他錯誤也繼續嘗試
      console.log(`⏭️ 跳過失敗的批次，繼續處理剩餘批次...`);
    }
    
    // 批次間加入短暫延遲，避免過度負載
    await new Promise(resolve => setTimeout(resolve, 1000));
  }
  
  // 結果統計
  console.log(`📊 分批查詢完成統計:`);
  console.log(`   成功批次: ${successCount}/${batches.length}`);
  console.log(`   總記錄數: ${allResults.length}`);
  console.log(`   失敗批次: ${partialFailures.length}`);
  
  if (partialFailures.length > 0) {
    console.log(`⚠️ 部分批次查詢失敗:`);
    partialFailures.forEach(failure => {
      console.log(`   - ${failure.batch}: ${failure.error}`);
    });
  }
  
  // 按時間排序合併結果
  if (allResults.length > 0) {
    allResults.sort((a, b) => 
      new Date(a.EdgeStartTimestamp || a.timestamp) - new Date(b.EdgeStartTimestamp || b.timestamp)
    );
    console.log(`✅ 數據合併完成，時間範圍: ${allResults[0]?.EdgeStartTimestamp} - ${allResults[allResults.length-1]?.EdgeStartTimestamp}`);
  }
  
  // 如果完全沒有數據，拋出錯誤
  if (allResults.length === 0) {
    const errorMsg = partialFailures.length > 0 
      ? `所有批次查詢失敗。主要錯誤: ${partialFailures[0].error}`
      : '未找到任何數據';
    throw new Error(errorMsg);
  }
  
  // 如果部分失敗但有數據，記錄警告
  if (partialFailures.length > 0 && allResults.length > 0) {
    console.log(`⚠️ 注意：部分數據缺失，但已獲得 ${allResults.length} 筆有效記錄進行分析`);
  }
  
  return allResults;
}

// 查詢單個時間批次
async function queryCustomTimeRangeBatch(startTime, endTime, batchIndex, totalBatches) {
  try {
    console.log(`🔍 查詢批次 ${batchIndex}/${totalBatches}: ${startTime.toISOString()} - ${endTime.toISOString()}`);
    
    // 計算批次時間範圍以優化查詢大小
    const timeDiff = endTime.getTime() - startTime.getTime();
    const hours = timeDiff / (1000 * 60 * 60);
    let batchSizeKey = '1d';
    
    if (hours <= 0.5) batchSizeKey = '30m';
    else if (hours <= 1) batchSizeKey = '1h';
    else if (hours <= 2) batchSizeKey = '2h';
    else if (hours <= 6) batchSizeKey = '6h';
    else if (hours <= 24) batchSizeKey = '1d';
    else batchSizeKey = '3d';
    
    const querySize = getBatchQuerySizeByTimeRange(batchSizeKey);
    console.log(`📏 批次 ${batchIndex} 時間跨度: ${hours.toFixed(1)}小時，查詢大小: ${querySize}`);
    
    // 使用自定義時間範圍查詢
    const elkData = await elkMCPClient.queryElasticsearchCustomTime(
      startTime.toISOString(),
      endTime.toISOString(),
      {} // 目前使用預設查詢大小，未來可以優化
    );
    
    if (!elkData.hits || elkData.hits.length === 0) {
      console.log(`📭 批次 ${batchIndex} 無數據`);
      return [];
    }
    
    console.log(`📊 批次 ${batchIndex} 獲得 ${elkData.hits.length} 筆原始記錄`);
    
    // 轉換數據格式
    const validHits = elkData.hits.filter(hit => hit && hit.source && hit.source["@timestamp"]);
    const logEntries = validHits
      .map(hit => convertELKToLogEntry(hit.source))
      .filter(entry => entry !== null);
    
    console.log(`✅ 批次 ${batchIndex} 成功轉換 ${logEntries.length} 筆有效記錄`);
    
    return logEntries;
    
  } catch (error) {
    console.error(`❌ 批次 ${batchIndex} 查詢失敗:`, error.message);
    
    // 增強錯誤處理：提供具體的錯誤分類
    if (error.message.includes('timeout') || error.message.includes('timed out')) {
      throw new Error(`批次 ${batchIndex} 查詢超時，建議縮小時間範圍`);
    }
    
    if (error.message.includes('Connection') || error.message.includes('MCP')) {
      throw new Error(`批次 ${batchIndex} 連接失敗，請檢查ELK服務狀態`);
    }
    
    throw new Error(`批次 ${batchIndex} 查詢失敗: ${error.message}`);
  }
}

// 單批次查詢（用於小時間範圍）
async function querySingleBatch(timeRange, batchIndex, totalBatches, progressCallback = null) {
  try {
    if (progressCallback) {
      progressCallback({
        type: 'batch_start',
        batchIndex,
        totalBatches,
        description: `單次查詢 ${timeRange}`,
        timeRange: timeRange
      });
    }
    
    const elkData = await elkMCPClient.queryElasticsearch(timeRange);
    
    if (!elkData.hits || elkData.hits.length === 0) {
      if (progressCallback) {
        progressCallback({
          type: 'batch_complete',
          batchIndex,
          totalBatches,
          recordCount: 0,
          success: true
        });
      }
      return [];
    }
    
    const validHits = elkData.hits.filter(hit => hit && hit.source && hit.source["@timestamp"]);
    const logEntries = validHits
      .map(hit => convertELKToLogEntry(hit.source))
      .filter(entry => entry !== null);
    
    if (progressCallback) {
      progressCallback({
        type: 'batch_complete',
        batchIndex,
        totalBatches,
        recordCount: logEntries.length,
        success: true
      });
    }
    
    return logEntries;
    
  } catch (error) {
    if (progressCallback) {
      progressCallback({
        type: 'batch_error',
        batchIndex,
        totalBatches,
        error: error.message
      });
    }
    throw error;
  }
}

// 查詢實際ELK資料（基於現有數據範圍）- 使用分批策略
async function queryActualELKData(timeRange, retryCount = 0, progressCallback = null) {
  console.log(`🔍 查詢實際ELK資料 (範圍: ${timeRange}, 嘗試: ${retryCount + 1})...`);
  
  try {
    // 使用新的分批查詢策略
    const logEntries = await queryELKDataInBatches(timeRange, progressCallback);
    
    if (!logEntries || logEntries.length === 0) {
      console.log('⚠️ 未找到ELK日誌資料');
      return [];
    }
    
    console.log(`✅ 分批查詢完成，總共獲得 ${logEntries.length} 筆記錄`);
    console.log(`📅 數據時間範圍: ${logEntries[0]?.EdgeStartTimestamp} - ${logEntries[logEntries.length-1]?.EdgeStartTimestamp}`);
    
    return logEntries;
    
  } catch (error) {
    console.error(`❌ 查詢實際ELK資料失敗 (嘗試 ${retryCount + 1}):`, error.message);
    
    // 如果是部分數據錯誤但有結果，嘗試降級處理
    if (error.message.includes('部分數據缺失') && retryCount === 0) {
      console.log('⚠️ 檢測到部分數據缺失，但可能仍有可用數據，繼續處理...');
      // 這種情況下，分批查詢函數會返回可用的數據
      // 所以這個錯誤可能不會到達這裡，但保留作為安全網
    }
    
    // 對於超時錯誤，提供更友好的建議
    if (error.message.includes('timeout') || error.message.includes('timed out')) {
      const suggestion = timeRange === '30d' 
        ? '請嘗試7天範圍' 
        : timeRange === '7d' 
        ? '請嘗試3天範圍' 
        : '請嘗試1天範圍';
      
      throw new Error(`查詢超時：${timeRange} 範圍仍然過大。${suggestion}，或稍後再試。`);
    }
    
    // 對於其他錯誤，提供具體的解決建議
    throw new Error(`數據查詢失敗：${error.message}。建議檢查ELK連接或嘗試較小的時間範圍。`);
  }
}

// 根據時間範圍獲取單批次查詢大小（優化後的分批策略）
function getBatchQuerySizeByTimeRange(batchSize) {
  const sizeMap = {
    '30m': 1500,  // 30分鐘批次
    '1h': 2000,   // 1小時批次
    '2h': 2500,   // 2小時批次
    '6h': 3000,   // 6小時批次
    '1d': 3500,   // 1天批次
    '3d': 4000    // 3天批次（最大批次）
  };
  console.log(`📊 批次大小 ${batchSize} 對應查詢大小: ${sizeMap[batchSize] || 3000}`);
  return sizeMap[batchSize] || 3000;
}

// 計算實際時間範圍
function calculateActualPeriods(previousData, currentData, timeRange) {
  const getTimeRange = (data) => {
    if (data.length === 0) return { start: null, end: null };
    
    const timestamps = data.map(entry => new Date(entry.EdgeStartTimestamp || entry.timestamp));
    const start = new Date(Math.min(...timestamps));
    const end = new Date(Math.max(...timestamps));
    
    return { start, end };
  };
  
  const previousRange = getTimeRange(previousData);
  const currentRange = getTimeRange(currentData);
  
  const formatDateRange = (start, end) => {
    if (!start || !end) return 'N/A';
    
    const formatDate = (date) => {
      return date.toLocaleDateString('zh-TW', {
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit'
      });
    };
    
    return `${formatDate(start)} - ${formatDate(end)}`;
  };
  
  return {
    current: {
      start: currentRange.start,
      end: currentRange.end,
      label: `當前時期 (${formatDateRange(currentRange.start, currentRange.end)})`
    },
    previous: {
      start: previousRange.start,
      end: previousRange.end,
      label: `上一時期 (${formatDateRange(previousRange.start, previousRange.end)})`
    }
  };
}

// 查詢特定時期的ELK資料（舊方法，保留備用）
async function queryELKPeriodData(period) {
  try {
    console.log(`🔍 查詢時期資料: ${period.start.toISOString()} - ${period.end.toISOString()}`);
    
    // 確保 ELK 連接已建立
    await elkMCPClient.ensureConnection();
    
    // 建構時間範圍查詢
    const query = {
      query: {
        range: {
          "@timestamp": {
            gte: period.start.toISOString(),
            lte: period.end.toISOString()
          }
        }
      },
      sort: [{ "@timestamp": { order: "asc" } }],
      size: 10000 // 根據需要調整
    };

    console.log('📊 執行自定義時間範圍查詢...');
    console.log('查詢時間範圍:', period.start.toISOString(), 'to', period.end.toISOString());
    console.log('索引:', ELK_CONFIG.elasticsearch.index);

    // 使用確保連接後的 elkMCPClient 查詢
    const result = await elkMCPClient.client.callTool({
      name: 'search',
      arguments: {
        index: ELK_CONFIG.elasticsearch.index,
        query_body: query
      }
    });

    if (result.isError) {
      throw new Error(`ELK查詢失敗: ${result.content[0]?.text || 'Unknown error'}`);
    }

    // 處理 MCP Server 的回應 (複製現有邏輯)
    const responseText = result.content[0]?.text || '';
    console.log('MCP Server 回應 (摘要):', responseText.substring(0, 200) + '...');
    
    // 檢查是否有第二個 content（實際的資料）
    const dataText = result.content[1]?.text || responseText;
    console.log('實際資料長度:', dataText.length, '前 100 字元:', dataText.substring(0, 100));
    
    let records;
    
    try {
      // 首先嘗試解析為記錄陣列（最常見的情況）
      records = JSON.parse(dataText);
      if (Array.isArray(records)) {
        console.log(`✅ 解析為記錄陣列，找到 ${records.length} 筆記錄`);
        return records.map(record => convertELKToLogEntry(record));
      } else {
        // 如果不是陣列，可能是標準 Elasticsearch 格式
        console.log('⚠️ 回應不是陣列格式，嘗試提取hits');
        const hits = records.hits?.hits || [];
        console.log(`✅ 從hits中找到 ${hits.length} 筆記錄`);
        return hits.map(hit => convertELKToLogEntry(hit._source));
      }
    } catch (e) {
      // 如果都無法解析，嘗試從摘要中提取數字
      console.log('⚠️ 無法解析JSON格式，嘗試解析摘要');
      const match = responseText.match(/Total results: (\d+)/);
      if (match) {
        const totalCount = parseInt(match[1]);
        console.log(`從摘要中發現 ${totalCount} 筆記錄，但無法解析詳細資料`);
        // 返回空陣列但記錄數量
        return [];
      }
      console.log('⚠️ 無法解析任何資料，回傳空陣列');
      return [];
    }
    
  } catch (error) {
    console.error(`❌ 查詢時期資料失敗:`, error);
    throw error;
  }
}

// 調試端點：檢查時間分組問題
app.get('/api/debug/time-grouping', async (req, res) => {
  try {
    console.log('🔍 開始調試時間分組...');
    
    // 查詢少量實際數據
    const elkData = await elkMCPClient.queryElasticsearch('auto');
    
    if (!elkData.hits || elkData.hits.length === 0) {
      return res.json({ error: '沒有找到數據' });
    }
    
    // 轉換前10筆數據
    const logEntries = elkData.hits.slice(0, 10).map(hit => convertELKToLogEntry(hit.source));
    
    // 分析時間分組
    const results = [];
    const groupInterval = 24 * 60 * 60 * 1000; // 1天
    
    logEntries.forEach((entry, i) => {
      const timestamp = new Date(entry.EdgeStartTimestamp || entry.timestamp);
      const timeKey = Math.floor(timestamp.getTime() / groupInterval) * groupInterval;
      const requestBytes = parseInt(entry.ClientRequestBytes) || 0;
      
      results.push({
        index: i,
        originalTimestamp: entry.EdgeStartTimestamp,
        parsedTimestamp: timestamp.toISOString(),
        timeKey: new Date(timeKey).toISOString(),
        clientRequestBytes: requestBytes,
        clientIP: entry.ClientIP
      });
    });
    
    res.json({
      message: '時間分組調試',
      totalRecords: elkData.hits.length,
      sampleData: results,
      groupInterval: `${groupInterval}ms (${groupInterval / (24*60*60*1000)}天)`
    });
    
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// 輸入驗證中間件
const validateTimeRange = [
  body('dataSource').optional().isIn(['file', 'elk']).withMessage('資料來源必須是file或elk'),
  body('timeRange').optional().matches(/^(\d+[mhd]|auto)$/).withMessage('時間範圍格式不正確'),
  body('startTime').optional().isISO8601().withMessage('開始時間格式不正確'),
  body('endTime').optional().isISO8601().withMessage('結束時間格式不正確'),
];

// 新增：攻擊來源統計API (安全版本)
app.post('/api/attack-source-stats', validateTimeRange, async (req, res) => {
  try {
    // 驗證輸入
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ 
        error: '輸入驗證失敗', 
        details: errors.array().map(err => err.msg)
      });
    }

    const { model, dataSource = 'file', timeRange = 'auto', startTime, endTime, apiKey: clientApiKey } = req.body;
    
    // 使用後端環境變數中的API Key，如果無效則回退到客戶端提供的API Key（臨時方案）
    let apiKey = securityConfig.gemini.apiKey;
    let usingClientKey = false;
    
    if (!isValidApiKey(apiKey)) {
      console.warn('⚠️  後端API Key無效，嘗試使用客戶端提供的API Key（臨時方案）');
      apiKey = clientApiKey;
      usingClientKey = true;
      
      if (!isValidApiKey(apiKey)) {
        console.error('❌ 沒有有效的API Key可用');
        return res.status(400).json({ 
          error: 'API Key設置錯誤', 
          hint: '請設置後端環境變數GEMINI_API_KEY，或在前端AI設定中輸入API Key' 
        });
      }
    }
    
    if (usingClientKey) {
      console.log('🔑 使用客戶端提供的API Key（建議設置後端環境變數以提高安全性）');
    }

    console.log(`📊 開始載入攻擊來源統計 (資料來源: ${dataSource})`);
    
    // 驗證時間範圍
    if (startTime && endTime) {
      const start = new Date(startTime);
      const end = new Date(endTime);
      const diffHours = (end - start) / (1000 * 60 * 60);
      
      if (diffHours <= 0) {
        return res.status(400).json({ error: '結束時間必須晚於開始時間' });
      }
      
      if (diffHours > securityConfig.validation.maxTimeRangeHours) {
        return res.status(400).json({ 
          error: `時間範圍不能超過${securityConfig.validation.maxTimeRangeHours}小時` 
        });
      }
      
      console.log(`🕐 使用自定義時間範圍: ${startTime} 到 ${endTime} (${diffHours.toFixed(1)}小時)`);
    } else {
      console.log(`🕐 使用預設時間範圍: ${timeRange}`);
    }
    
    let analysisResult;
    
    if (dataSource === 'elk') {
      // 傳遞安全的配置到processELKLogs
      analysisResult = await processELKLogs({ 
        apiKey, 
        model: model || securityConfig.gemini.model, 
        timeRange, 
        startTime, 
        endTime 
      });
    } else {
      analysisResult = await processLogFile({ 
        apiKey, 
        model: model || securityConfig.gemini.model 
      });
    }

    // 提取攻擊來源統計資料
    const attackData = analysisResult.attackData;
    if (!attackData) {
      return res.json({
        topIPs: [],
        topCountries: [],
        topURIs: [],
        topDomains: [],
        httpStatusStats: [],
      });
    }

    // 處理 HTTP 狀態碼統計
    const globalStats = analysisResult.globalStats || {};
    const httpStatusStats = globalStats.httpStatusCounts ? 
      Array.from(globalStats.httpStatusCounts.entries())
        .map(([status, count]) => ({ status, count }))
        .sort((a, b) => b.count - a.count)
      : [];

    res.json({
      topIPs: attackData.topIPs || [],
      topCountries: attackData.topCountries || [],
      topURIs: attackData.topURIs || [],
      topDomains: attackData.allAttacks || [],
      httpStatusStats: httpStatusStats,
      totalRequests: attackData.totalRequests || 0,
      uniqueIPs: attackData.uniqueIPs || 0
    });

  } catch (error) {
    console.error('❌ 攻擊來源統計失敗:', error);
    res.status(500).json({ 
      error: '攻擊來源統計失敗', 
      details: error.message 
    });
  }
});

// ELK 連接預熱（完全隔離，不影響其他功能）
async function warmupELKConnection() {
  try {
    console.log('🔥 開始 ELK 連接預熱...');
    
    // 檢查是否配置了ELK
    if (!ELK_CONFIG.mcp.serverUrl || ELK_CONFIG.mcp.serverUrl.includes('localhost')) {
      console.log('⚠️ 跳過 ELK 預熱：未配置生產環境 ELK 服務器');
      return;
    }
    
    // 設置短超時，避免阻塞
    const timeoutPromise = new Promise((_, reject) => {
      setTimeout(() => reject(new Error('ELK 預熱超時')), 5000); // 5秒超時
    });
    
    // 嘗試建立連接（不強制要求成功，完全隔離）
    const connectionPromise = elkMCPClient.testConnection();
    
    const connected = await Promise.race([connectionPromise, timeoutPromise]);
    
    if (connected) {
      console.log('✅ ELK 連接預熱成功');
    } else {
      console.log('⚠️ ELK 連接預熱失敗，但不影響系統啟動');
    }
  } catch (error) {
    // 完全靜默處理 ELK 錯誤，確保不影響 AI 功能
    console.log('⚠️ ELK 連接預熱失敗:', error.message);
    console.log('💡 系統將在首次使用時建立 ELK 連接，AI 功能不受影響');
    
    // 清理任何可能的殘留連接
    try {
      if (elkMCPClient && elkMCPClient.disconnect) {
        elkMCPClient.disconnect();
      }
    } catch (cleanupError) {
      // 靜默處理清理錯誤
    }
  }
}

// 啟動服務
const port = 8080;
app.listen(port, async () => {
  console.log(`🚀 Backend API 已啟動: http://localhost:${port}`);
  console.log('📊 DDoS 攻擊圖表分析系統已就緒');
  console.log('🤖 AI 分析功能已就緒 (支援 Gemini 和 Ollama)');
  
  // 異步執行ELK預熱（完全隔離，不阻塞啟動，不影響AI功能）
  setTimeout(() => {
    warmupELKConnection().catch(err => {
      console.log('🔇 ELK預熱過程靜默處理錯誤（AI功能不受影響）:', err.message);
    });
  }, 2000); // 等待2秒後開始預熱，確保 AI 服務完全就緒
  
  console.log('✨ 系統完全就緒！AI 測試功能可立即使用');
});
